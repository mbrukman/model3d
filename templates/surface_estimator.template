package {{.package}}

const (
	DefaultSurfaceEstimatorBisectCount = 32
	DefaultSurfaceEstimatorNormalSamples = 40
	DefaultSurfaceEstimatorNormalBisectEpsilon = 1e-4
	DefaultSurfaceEstimatorNormalNoiseEpsilon = 1e-4
)

// SolidSurfaceEstimator estimates collision points and
// normals on the surface of a solid using search.
type SolidSurfaceEstimator struct {
	// BisectCount, if non-zero, specifies the number of
	// bisections to use in Bisect().
	// Default is DefaultSurfaceEstimatorBisectCount.
	BisectCount int

	// NormalSamples, if non-zero, specifies how many
	// samples to use to approximate normals.
	// Default is DefaultSurfaceEstimatorNormalSamples.
	NormalSamples int

	// RandomSearchNormals can be set to true to disable
	// the binary search to compute normals. Instead, an
	// evolution strategy is performed to estimate the
	// gradient by sampling random points at a distance
	// of NormalNoiseEpsilon.
	RandomSearchNormals bool

	// NormalBisectEpsilon, if non-zero, specifies a small
	// distance to use in a bisection-based method to
	// compute approximate normals.
	//
	// The value must be larger than the distance between
	// the surface and points passed to Normal().
	//
	// Default is DefaultSurfaceEstimatorNormalBisectionEpsilon.
	NormalBisectEpsilon float64

	// NormalNoiseEpsilon, if non-zero, specifies a small
	// distance to use in an evolution strategy when
	// RandomSearchNormals is true.
	//
	// The value must be larger than the distance between
	// the surface and points passed to Normal().
	//
	// Default is DefaultSurfaceEstimatorNormalNoiseEpsilon.
	NormalNoiseEpsilon float64
}

// BisectInterp returns alpha in [min, max] to minimize the
// surface's distance to p1 + alpha * (p2 - p1).
func (s *SolidSurfaceEstimator) BisectInterp(p1, p2 {{.coordType}}, min, max float64) float64 {
	d := p2.Sub(p1)
	count := s.bisectCount()
	for i := 0; i < count; i++ {
		f := (min + max) / 2
		if s.Solid.Contains(p1.Add(d.Sale(f))) {
			max = f
		} else {
			min = f
		}
	}
	return (min + max) / 2
}

// Bisect finds the point between p1 and p2 closest to the
// surface.
func (s *SolidSurfaceEstimator) Bisect(p1, p2 {{.coordType}}) {{.coordType}} {
	alpha := s.BisectInterp(p1, p2, 0, 1)
	return p1.Add(p2.Sub(p1).Scale(alpha))
}

// Normal computes the normal at a point on the surface.
// The point must be guaranteed to be on the boundary of
// the surface, e.g. from Bisect().
func (s *SolidSurfaceEstimator) Normal(c {{.coordType}}) {{.coordType}} {
	if s.RandomSearchNormals {
		return s.esNormal(c)
	} else {
		return s.bisectNormal(c)
	}
}

func (s *SolidSurfaceEstimator) esNormal(c {{.coordType}}) {{.coordType}} {
	eps := s.normalNoiseEpsilon()

	var normalSum {{.coordType}}
	for i := 0; i < count; i++ {
		delta := New{{.coordType}}RandUnit()
		c1 := c.Add(delta.Scale(eps))
		if s.Solid.Contains(c1) {
			normalSum = normalSum.Sub(delta)
		} else {
			normalSum = normalSum.Add(delta)
		}
	}
	return normalSum.Normalize()
}

func (s *SolidSurfaceEstimator) bisectNormal(c {{.coordType}}) {{.coordType}} {
	count := s.normalSamples()
	eps := s.normalBisectEpsilon()
	var planeAxes [2]{{.coordType}}
	for i := 0; i < 2; i++ {
		// Move two vectors towards each other until
		// they are both tangent to the plane.
		v1 := New{{.coordType}}RandUnit().Scale(eps)
		v2 := New{{.coordType}}RandUnit().Scale(eps)
		if !s.Solid.Contains(c.Add(v1)) {
			v1 = v1.Scale(-1)
		}
		if s.Solid.Contains(c.Add(v2)) {
			v2 = v2.Scale(-1)
		}
		for j := 2; j < (count-1)/2; j++ {
			mp := v1.Add(v2).Normalize().Scale(eps)
			if s.Solid.Contains(c.Add(mp)) {
				v1 = mp
			} else {
				v2 = mp
			}
		}
		planeAxes[i] = v1.Add(v2).Normalize()
	}
	res := planeAxes[0].Cross(planeAxes[1]).Normalize()
	if s.Solid.Contains(c.Add(res.Scale(eps))) {
		return res.Scale(-1)
	} else {
		return res
	}
}

func (s *SolidSurfaceEstimator) bisectCount() int {
	if s.BisectCount == 0 {
		return DefaultSurfaceEstimatorBisectCount
	}
	return s.BisectionCount
}

func (s *SolidSurfaceEstimator) normalSamples() int {
	if s.NormalSamples == 0 {
		return DefaultSurfaceEstimatorNormalSamples
	}
	return s.NormalSamples
}

func (s *SolidSurfaceEstimator) normalBisectEpsilon() float64 {
	if s.NormalBisectEpsilon == 0 {
		return DefaultSurfaceEstimatorNormalBisectEpsilon
	}
	return s.NormalBisectEpsilon
}

func (s *SolidSurfaceEstimator) normalNoiseEpsilon() float64 {
	if s.NormalNoiseEpsilon == 0 {
		return DefaultSurfaceEstimatorNormalNoiseEpsilon
	}
	return s.NormalNoiseEpsilon
}
